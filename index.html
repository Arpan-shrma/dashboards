<!DOCTYPE html>
<html>
<head>
  <title>IESF Bathymetry Dashboard</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/chart.js@3.9.1/dist/chart.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .hero-section {
      padding: 60px 20px 40px;
      text-align: center;
      color: white;
      position: relative;
    }

    .hero-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
    }

    .hero-content {
      position: relative;
      z-index: 1;
      max-width: 1000px;
      margin: 0 auto;
    }

    .hero-title {
      font-size: clamp(2.5rem, 5vw, 4rem);
      font-weight: 800;
      margin-bottom: 16px;
      background: linear-gradient(45deg, #fff, #f0f0f0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .hero-subtitle {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 32px;
      font-weight: 400;
    }

    .stats-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin: 32px 0;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .stat-card {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.2);
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-5px);
    }

    .stat-number {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
    }

    .dashboard-container {
      background: white;
      border-radius: 24px 24px 0 0;
      margin-top: 20px;
      min-height: 80vh;
      box-shadow: 0 -8px 32px rgba(0,0,0,0.1);
      position: relative;
    }

    .dashboard-panel { 
      max-width: 1400px; 
      margin: 0 auto; 
      padding: 50px 20px;
    }

    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 40px;
      flex-wrap: wrap;
      gap: 20px;
    }

    .dashboard-title { 
      font-size: 2.2rem; 
      font-weight: 700; 
      color: #2d3748;
      margin: 0;
    }

    .connection-status {
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-github { background: #28a745; color: white; }
    .status-sample { background: #ffc107; color: #212529; }
    .status-error { background: #dc3545; color: white; }

    .controls-section {
      background: #f8f9fa;
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 32px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.05);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
    }

    .control-label {
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 8px;
      font-size: 0.9rem;
    }

    .control-select {
      padding: 12px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      background: white;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .control-select:focus {
      outline: none;
      border-color: #3182ce;
      box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
    }

    .refresh-btn {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }

    .refresh-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(40, 167, 69, 0.3);
    }

    .view-tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 32px;
      flex-wrap: wrap;
    }

    .view-tab {
      padding: 12px 24px;
      border: 2px solid #e2e8f0;
      border-radius: 25px;
      background: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
      color: #4a5568;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .view-tab.active {
      background: linear-gradient(135deg, #3182ce, #2c5282);
      color: white;
      border-color: transparent;
    }

    .view-tab:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .visualization-container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      overflow: hidden;
      margin-bottom: 32px;
    }

    .viz-header {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 20px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 16px;
    }

    .viz-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin: 0;
    }

    .viz-content {
      padding: 24px;
    }

    .threejs-wrapper {
      position: relative;
      display: flex;
      gap: 24px;
      align-items: flex-start;
    }

    .threejs-container {
      flex: 1;
      height: 500px;
      background: linear-gradient(135deg, #001122, #003366);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
      cursor: grab;
      border: 2px solid #667eea;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .threejs-container:active {
      cursor: grabbing;
    }

    .bathymetry-info {
      margin-bottom: 24px;
      padding: 0 0 24px 0;
      border-bottom: 2px solid #e2e8f0;
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .info-card {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      border-radius: 12px;
      padding: 20px;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .info-card h4 {
      color: #2d3748;
      margin-bottom: 12px;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .info-card p {
      color: #4a5568;
      font-size: 0.9rem;
      line-height: 1.5;
      margin: 0;
    }

    .model-legend {
      width: 280px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.3);
    }

    .model-legend h4 {
      color: #2d3748;
      margin-bottom: 16px;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-items {
      margin-bottom: 16px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 8px 0;
      font-size: 0.9rem;
      color: #4a5568;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 12px;
      border: 2px solid #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .legend-note {
      background: #e6f3ff;
      border-radius: 8px;
      padding: 12px;
      border-left: 3px solid #3182ce;
    }

    .legend-note small {
      color: #2c5282;
      line-height: 1.4;
    }

    .depth-scale {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
      min-width: 200px;
    }

    .depth-scale h4 {
      color: #2d3748;
      margin-bottom: 12px;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .scale-bar {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .scale-segment {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 600;
      color: white;
      text-align: center;
    }

    .scale-segment.shallow { background: #87CEEB; }
    .scale-segment.medium { background: #4682B4; }
    .scale-segment.deep { background: #191970; }
    .scale-segment.very-deep { background: #000080; }

    .lake-preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 24px;
    }

    .lake-preview-card {
      background: rgba(255,255,255,0.9);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
      border: 1px solid #e2e8f0;
    }

    .lake-preview-card h4 {
      color: #2d3748;
      margin-bottom: 8px;
    }

    .lake-preview-card p {
      color: #718096;
      margin-bottom: 16px;
      font-size: 0.9rem;
    }

    .preview-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .preview-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    #mapContainer {
      width: 100%;
      height: 500px;
      border-radius: 12px;
      z-index: 1;
      background: #f0f0f0;
      border: 1px solid #ddd;
    }

    .leaflet-container {
      height: 500px !important;
      width: 100% !important;
      border-radius: 12px;
    }

    .threejs-controls {
      position: absolute;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      z-index: 10;
    }

    .control-btn {
      background: rgba(255,255,255,0.9);
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .control-btn:hover {
      background: white;
      transform: translateY(-1px);
    }

    .control-btn.active {
      background: #3182ce;
      color: white;
    }

    .chart-container {
      width: 100%;
      height: 400px;
      position: relative;
    }

    .data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 24px;
      margin-top: 32px;
    }

    .data-card {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08);
      overflow: hidden;
      border: 1px solid #f0f0f0;
    }

    .card-header {
      background: linear-gradient(135deg, #4299e1, #3182ce);
      color: white;
      padding: 16px 20px;
      font-weight: 600;
    }

    .card-content {
      padding: 20px;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #f0f0f0;
    }

    .metric-row:last-child {
      border-bottom: none;
    }

    .metric-label {
      color: #718096;
      font-size: 0.9rem;
    }

    .metric-value {
      font-weight: 600;
      color: #2d3748;
    }

    .loading {
      text-align: center;
      padding: 60px;
      color: #718096;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e2e8f0;
      border-top: 3px solid #3182ce;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .download-section {
      background: #f8f9fa;
      border-radius: 16px;
      padding: 24px;
      margin-top: 32px;
      text-align: center;
    }

    .download-btn {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      margin: 0 8px;
      transition: all 0.3s ease;
    }

    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(40, 167, 69, 0.3);
    }

    .error-message {
      background: #fed7d7;
      border: 1px solid #feb2b2;
      color: #c53030;
      padding: 16px;
      border-radius: 12px;
      margin: 16px 0;
      text-align: center;
    }

    .multi-lake-message {
      text-align: center; 
      padding: 60px; 
      color: #718096;
    }

    .multi-lake-message h3 {
      margin-bottom: 16px;
      color: #4a5568;
    }

    .multi-lake-message .lake-icon {
      font-size: 3rem; 
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .hero-section { padding: 40px 20px 30px; }
      .dashboard-panel { padding: 30px 15px; }
      .controls-grid { grid-template-columns: 1fr; }
      .view-tabs { justify-content: center; }
      .viz-header { flex-direction: column; align-items: flex-start; }
      .threejs-controls { position: relative; top: auto; right: auto; margin-top: 16px; }
    }
    /* Back to Home Button */
.back-to-home {
  position: fixed;
  top: 20px;
  left: 20px;
  background: rgba(255,255,255,0.95);
  backdrop-filter: blur(10px);
  border: 2px solid rgba(0,0,0,0.1);
  color: #333;
  padding: 12px 20px;
  border-radius: 25px;
  text-decoration: none;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s ease;
  z-index: 1000;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  gap: 8px;
}

.back-to-home:hover {
  background: white;
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.15);
  color: #667eea;
}

.back-to-home:active {
  transform: translateY(0);
}

/* Responsive adjustment */
@media (max-width: 768px) {
  .back-to-home {
    position: relative;
    top: auto;
    left: auto;
    margin: 10px;
    display: inline-flex;
  }
}
  </style>
</head>
<body>
  <a href="homepage.html" class="back-to-home">
  <i class="fas fa-arrow-left"></i>
  Back to Home
</a>
  <!-- Hero Section -->
  <div class="hero-section">
    <div class="hero-content">
      <h1 class="hero-title">IESF Bathymetry Dashboard</h1>
      <p class="hero-subtitle">3D Lake Analysis & Environmental Monitoring Platform</p>
      
      <div class="stats-row">
        <div class="stat-card">
          <div class="stat-number" id="totalMeasurements">0</div>
          <div class="stat-label">Total Measurements</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="activeLakes">0</div>
          <div class="stat-label">Lake Systems</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="maxDepth">0m</div>
          <div class="stat-label">Maximum Depth</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="gridCells">0</div>
          <div class="stat-label">Grid Cells</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Dashboard -->
  <div class="dashboard-container">
    <div class="dashboard-panel">
      <!-- Header -->
      <div class="dashboard-header">
        <h2 class="dashboard-title">Interactive Bathymetry Analysis</h2>
        <div class="connection-status" id="connectionStatus">
          <span>üîó</span>
          <span id="statusText">Loading...</span>
        </div>
      </div>

      <!-- Controls Section -->
      <div class="controls-section">
        <div class="controls-grid">
          <div class="control-group">
            <label class="control-label">Lake System</label>
            <select class="control-select" id="lakeSelect">
              <option value="all">All Lakes</option>
            </select>
          </div>
          <div class="control-group">
            <label class="control-label">Management Zone</label>
            <select class="control-select" id="zoneSelect">
              <option value="all">All Zones</option>
            </select>
          </div>
          <div class="control-group">
            <label class="control-label">Depth Range</label>
            <select class="control-select" id="depthSelect">
              <option value="all">All Depths</option>
              <option value="shallow">Shallow (0-2m)</option>
              <option value="medium">Medium (2-5m)</option>
              <option value="deep">Deep (5-10m)</option>
              <option value="very-deep">Very Deep (10m+)</option>
            </select>
          </div>
          <div class="control-group">
            <label class="control-label">Season</label>
            <select class="control-select" id="seasonSelect">
              <option value="all">All Seasons</option>
              <option value="Spring">Spring</option>
              <option value="Summer">Summer</option>
              <option value="Fall">Fall</option>
              <option value="Winter">Winter</option>
            </select>
          </div>
        </div>
        
        <button class="refresh-btn" onclick="refreshData()">üîÑ Refresh Data</button>
      </div>

      <!-- View Tabs -->
      <div class="view-tabs">
        <div class="view-tab active" data-view="3d" onclick="switchView('3d')">
          <span>üì¶</span> 3D Bathymetry
        </div>
        <div class="view-tab" data-view="map" onclick="switchView('map')">
          <span>üó∫Ô∏è</span> Lake Locations
        </div>
        <div class="view-tab" data-view="charts" onclick="switchView('charts')">
          <span>üìä</span> Depth Analysis
        </div>
        <div class="view-tab" data-view="temperature" onclick="switchView('temperature')">
          <span>üå°Ô∏è</span> Temperature Profile
        </div>
        <div class="view-tab" data-view="spatial" onclick="switchView('spatial')">
          <span>üó∫Ô∏è</span> Spatial Distribution
        </div>
      </div>

      <!-- 3D Visualization -->
      <div class="visualization-container" id="view-3d">
        <!-- Educational Content Section -->
        <div class="bathymetry-info" id="bathymetryInfo">
          <div class="info-grid">
            <div class="info-card">
              <h4>üìä What is Bathymetry?</h4>
              <p>Bathymetry is the measurement of water depth in oceans, seas, and lakes. It creates underwater topographic maps showing the shape of lake bottoms.</p>
            </div>
            <div class="info-card">
              <h4>üî¨ Data Collection</h4>
              <p>Our bathymetry data is collected using sonar depth finders and temperature sensors deployed across lake surfaces in systematic grid patterns.</p>
            </div>
            <div class="info-card">
              <h4>üå°Ô∏è Temperature Profiling</h4>
              <p>Water temperature varies with depth, creating thermal layers. Deeper waters are typically colder, affecting fish habitat and oxygen levels.</p>
            </div>
            <div class="info-card">
              <h4>üéØ Conservation Value</h4>
              <p>Bathymetric maps help identify critical fish spawning areas, plan conservation efforts, and monitor ecosystem health over time.</p>
            </div>
          </div>
        </div>

        <div class="viz-header">
          <h3 class="viz-title" id="viz3dTitle">3D Lake Bathymetry Model</h3>
          <div class="threejs-controls">
            <button class="control-btn" id="rotateBtn" onclick="toggleRotation()">‚ü≤ Rotate</button>
            <button class="control-btn" id="wireframeBtn" onclick="toggleWireframe()">‚óª Wireframe</button>
            <button class="control-btn" onclick="resetCamera()">üéØ Reset View</button>
          </div>
        </div>
        <div class="viz-content">
          <!-- 3D Model Container -->
          <div class="threejs-wrapper">
            <div class="threejs-container" id="threejsContainer"></div>
            
            <!-- 3D Model Legend - Only show when lake is selected -->
            <div class="model-legend" id="modelLegend" style="display: none;">
              <h4>üé® 3D Model Legend</h4>
              <div class="legend-items">
                <div class="legend-item">
                  <div class="legend-color" style="background: #8B4513;"></div>
                  <span>Lake Bottom (Sediment)</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: rgba(0, 105, 148, 0.6);"></div>
                  <span>Water Surface</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #ff0000;"></div>
                  <span>Warm Water (15¬∞C+)</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #ff8800;"></div>
                  <span>Moderate (12-15¬∞C)</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #0088ff;"></div>
                  <span>Cool Water (8-12¬∞C)</span>
                </div>
                <div class="legend-item">
                  <div class="legend-color" style="background: #004488;"></div>
                  <span>Cold Water (<8¬∞C)</span>
                </div>
              </div>
              <div class="legend-note">
                <small>üí° <strong>Tip:</strong> Drag to rotate, scroll to zoom. Temperature dots show thermal gradients throughout the water column.</small>
              </div>
            </div>

            <!-- Depth Scale - Only show when lake is selected -->
            <div class="depth-scale" id="depthScale" style="display: none;">
              <h4>üìè Depth Scale</h4>
              <div class="scale-bar">
                <div class="scale-segment shallow">0-2m Shallow</div>
                <div class="scale-segment medium">2-5m Medium</div>
                <div class="scale-segment deep">5-10m Deep</div>
                <div class="scale-segment very-deep">10m+ Very Deep</div>
              </div>
            </div>
          </div>
          
          <!-- Multi-lake Message -->
          <div id="allLakesMessage" class="multi-lake-message" style="display: none;">
            <div class="lake-icon">üèûÔ∏è</div>
            <h3>Multiple Lakes Selected</h3>
            <p>3D bathymetry model is available when viewing individual lakes.</p>
            <p>Select a specific lake from the dropdown above to view its detailed 3D model.</p>
            <div class="lake-preview-grid">
              <div class="lake-preview-card">
                <h4>Fish Lake</h4>
                <p>Max Depth: ~15m</p>
                <button onclick="selectLake('Fish Lake')" class="preview-btn">View 3D</button>
              </div>
              <div class="lake-preview-card">
                <h4>McFee Lake</h4>
                <p>Max Depth: ~8m</p>
                <button onclick="selectLake('McFee Lake')" class="preview-btn">View 3D</button>
              </div>
              <div class="lake-preview-card">
                <h4>Taits Lake</h4>
                <p>Max Depth: ~18m</p>
                <button onclick="selectLake('Taits Lake')" class="preview-btn">View 3D</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- OSM Map View -->
      <div class="visualization-container" id="view-map" style="display: none;">
        <div class="viz-header">
          <h3 class="viz-title">Lake Locations Map</h3>
          <div class="threejs-controls">
            <button class="control-btn" onclick="fitMapToBounds()">üó∫Ô∏è Fit to Data</button>
            <button class="control-btn" onclick="toggleMapLayers()">üè∑Ô∏è Toggle Labels</button>
          </div>
        </div>
        <div class="viz-content">
          <div id="mapContainer"></div>
        </div>
      </div>

      <!-- Charts View -->
      <div class="visualization-container" id="view-charts" style="display: none;">
        <div class="viz-header">
          <h3 class="viz-title">Lake Depth Analysis</h3>
        </div>
        <div class="viz-content">
          <div class="data-grid">
            <div class="data-card">
              <div class="card-header">Depth Distribution</div>
              <div class="card-content">
                <div class="chart-container">
                  <canvas id="depthChart"></canvas>
                </div>
              </div>
            </div>
            <div class="data-card">
              <div class="card-header">Lake Comparison</div>
              <div class="card-content">
                <div class="chart-container">
                  <canvas id="lakeChart"></canvas>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Temperature View -->
      <div class="visualization-container" id="view-temperature" style="display: none;">
        <div class="viz-header">
          <h3 class="viz-title">Temperature Analysis</h3>
        </div>
        <div class="viz-content">
          <div class="data-grid">
            <div class="data-card">
              <div class="card-header">Temperature Distribution by Lake</div>
              <div class="card-content">
                <div class="chart-container">
                  <canvas id="tempLakeChart"></canvas>
                </div>
              </div>
            </div>
            <div class="data-card">
              <div class="card-header">Thermal Zones</div>
              <div class="card-content">
                <div class="chart-container">
                  <canvas id="thermalChart"></canvas>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Spatial View -->
      <div class="visualization-container" id="view-spatial" style="display: none;">
        <div class="viz-header">
          <h3 class="viz-title">Spatial Distribution</h3>
        </div>
        <div class="viz-content">
          <div class="data-grid" id="spatialGrid">
            <!-- Populated by JavaScript -->
          </div>
        </div>
      </div>

      <!-- Download Section -->
      <div class="download-section">
        <h3 style="margin-bottom: 16px; color: #4a5568;">Export Bathymetry Data</h3>
        <button class="download-btn" onclick="downloadData('csv')">üìÑ Download CSV</button>
        <button class="download-btn" onclick="downloadData('geojson')">üó∫Ô∏è Download GeoJSON</button>
        <button class="download-btn" onclick="downloadData('json')">üìä Download JSON</button>
      </div>
    </div>
  </div>

  <script>
    // === CONFIGURATION ===
    const GITHUB_RAW_URL = 'https://raw.githubusercontent.com/Arpan-shrma/iesf_datasets/refs/heads/main/iesf_dashboard_bathymetry.csv';
    
    // === GLOBAL VARIABLES ===
    let allData = [];
    let filteredData = [];
    let scene, camera, renderer, lakeMesh, waterMesh;
    let isRotating = false;
    let isWireframe = false;
    let charts = {};
    let map, mapInitialized = false;
    let lakeMarkers = [];
    let measurementMarkers = [];
    let animationId = null;

    // Mouse control variables
    let mouseControls = {
      isMouseDown: false,
      mouseX: 0,
      mouseY: 0,
      targetRotationX: 0,
      targetRotationY: 0,
      currentRotationX: 0,
      currentRotationY: 0
    };

    // === IMPROVED CSV PARSER ===
    function parseCSV(csvText) {
      const lines = csvText.trim().split('\n');
      if (lines.length < 2) return [];
      
      const headers = lines[0].split(',').map(h => h.replace(/['"]/g, '').trim());
      
      return lines.slice(1).map(line => {
        // Better CSV parsing that handles quoted values
        const values = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            values.push(current.trim().replace(/['"]/g, ''));
            current = '';
          } else {
            current += char;
          }
        }
        values.push(current.trim().replace(/['"]/g, ''));
        
        const row = {};
        headers.forEach((header, index) => {
          let value = values[index] || '';
          
          // Convert numeric fields with better error handling
          if (['latitude', 'longitude', 'depth_m', 'temperature_c'].includes(header)) {
            const numValue = parseFloat(value);
            value = isNaN(numValue) ? 0 : numValue;
          }
          
          row[header] = value;
        });
        
        return row;
      }).filter(row => row.latitude && row.longitude && row.latitude !== 0 && row.longitude !== 0);
    }

    // === IMPROVED DATA LOADING ===
    async function loadData() {
      try {
        updateStatus('loading', 'Loading bathymetry data...');
        
        const response = await fetch(GITHUB_RAW_URL);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const csvText = await response.text();
        allData = parseCSV(csvText);
        
        if (allData.length === 0) {
          throw new Error('No valid data found in CSV');
        }
        
        console.log(`Successfully loaded ${allData.length} bathymetry records`);
        updateStatus('github', `GitHub Connected - ${allData.length} records`);
        
      } catch (error) {
        console.error('Data loading failed:', error);
        
        // Robust sample data with all required fields
        allData = generateSampleData();
        updateStatus('sample', `Sample Data - ${allData.length} records`);
      }
      
      // Initialize everything
      // Initialize everything - avoid circular calls
populateDropdowns();

// Apply filters WITHOUT calling updateStats (it will be called by update functions)
const lake = document.getElementById('lakeSelect').value;
const zone = document.getElementById('zoneSelect').value;
const depth = document.getElementById('depthSelect').value;
const season = document.getElementById('seasonSelect').value;

filteredData = allData.filter(item => {
  const lakeMatch = lake === 'all' || item.lake_name === lake;
  const zoneMatch = zone === 'all' || item.management_zone === zone;
  const seasonMatch = season === 'all' || item.estimated_season === season;
  
  let depthMatch = true;
  if (depth === 'shallow') depthMatch = item.depth_m <= 2;
  else if (depth === 'medium') depthMatch = item.depth_m > 2 && item.depth_m <= 5;
  else if (depth === 'deep') depthMatch = item.depth_m > 5 && item.depth_m <= 10;
  else if (depth === 'very-deep') depthMatch = item.depth_m > 10;
  
  return lakeMatch && zoneMatch && seasonMatch && depthMatch;
});

updateStats(); // Call this only once
init3D();
initMap();
initCharts();
    }

    function generateSampleData() {
      return [
        { measurement_id: 'FISH_001', latitude: 44.9033, longitude: -77.6684, grid_id: 'IESF_0267', management_zone: 'Core_Park', lake_name: 'Fish Lake', depth_m: 1.2, temperature_c: 12, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'shallow' },
        { measurement_id: 'FISH_002', latitude: 44.9034, longitude: -77.6684, grid_id: 'IESF_0267', management_zone: 'Core_Park', lake_name: 'Fish Lake', depth_m: 2.1, temperature_c: 10, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'shallow' },
        { measurement_id: 'FISH_003', latitude: 44.9033, longitude: -77.6685, grid_id: 'IESF_0267', management_zone: 'Core_Park', lake_name: 'Fish Lake', depth_m: 3.8, temperature_c: 8, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'medium' },
        { measurement_id: 'FISH_004', latitude: 44.9034, longitude: -77.6685, grid_id: 'IESF_0267', management_zone: 'Core_Park', lake_name: 'Fish Lake', depth_m: 6.8, temperature_c: 6, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'deep' },
        { measurement_id: 'FISH_005', latitude: 44.9035, longitude: -77.6684, grid_id: 'IESF_0267', management_zone: 'Core_Park', lake_name: 'Fish Lake', depth_m: 12.1, temperature_c: 4, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'very-deep' },
        { measurement_id: 'MCFEE_001', latitude: 44.9133, longitude: -77.6584, grid_id: 'IESF_0268', management_zone: 'Park_Edge', lake_name: 'McFee Lake', depth_m: 0.9, temperature_c: 15, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'shallow' },
        { measurement_id: 'MCFEE_002', latitude: 44.9134, longitude: -77.6584, grid_id: 'IESF_0268', management_zone: 'Park_Edge', lake_name: 'McFee Lake', depth_m: 1.9, temperature_c: 13, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'shallow' },
        { measurement_id: 'MCFEE_003', latitude: 44.9133, longitude: -77.6585, grid_id: 'IESF_0268', management_zone: 'Park_Edge', lake_name: 'McFee Lake', depth_m: 4.2, temperature_c: 9, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'medium' },
        { measurement_id: 'TAITS_001', latitude: 44.9233, longitude: -77.6784, grid_id: 'IESF_0269', management_zone: 'Core_Park', lake_name: 'Taits Lake', depth_m: 1.9, temperature_c: 13, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'shallow' },
        { measurement_id: 'TAITS_002', latitude: 44.9234, longitude: -77.6784, grid_id: 'IESF_0269', management_zone: 'Core_Park', lake_name: 'Taits Lake', depth_m: 8.9, temperature_c: 6, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'deep' },
        { measurement_id: 'TAITS_003', latitude: 44.9233, longitude: -77.6785, grid_id: 'IESF_0269', management_zone: 'Core_Park', lake_name: 'Taits Lake', depth_m: 15.2, temperature_c: 4, survey_date: '2024-10-24', estimated_season: 'Fall', data_quality: 'good', depth_category: 'very-deep' }
      ];
    }

    function updateStatus(type, text) {
      const statusElement = document.getElementById('connectionStatus');
      const statusText = document.getElementById('statusText');
      
      statusElement.className = 'connection-status';
      statusText.textContent = text;
      
      if (type === 'github') {
        statusElement.classList.add('status-github');
      } else if (type === 'sample') {
        statusElement.classList.add('status-sample');
      } else if (type === 'loading') {
        statusElement.classList.add('status-error');
      }
    }

    function populateDropdowns() {
      const lakes = [...new Set(allData.map(d => d.lake_name))].filter(Boolean);
      const zones = [...new Set(allData.map(d => d.management_zone))].filter(Boolean);
      
      // Populate lake dropdown
      const lakeSelect = document.getElementById('lakeSelect');
      lakeSelect.innerHTML = '<option value="all">All Lakes</option>';
      lakes.forEach(lake => {
        lakeSelect.innerHTML += `<option value="${lake}">${lake}</option>`;
      });
      
      // Populate zone dropdown
      const zoneSelect = document.getElementById('zoneSelect');
      zoneSelect.innerHTML = '<option value="all">All Zones</option>';
      zones.forEach(zone => {
        const displayZone = zone.replace(/_/g, ' ');
        zoneSelect.innerHTML += `<option value="${zone}">${displayZone}</option>`;
      });
    }

    // === FILTERING ===
    function applyFilters() {
      const lake = document.getElementById('lakeSelect').value;
      const zone = document.getElementById('zoneSelect').value;
      const depth = document.getElementById('depthSelect').value;
      const season = document.getElementById('seasonSelect').value;
      
      filteredData = allData.filter(item => {
        const lakeMatch = lake === 'all' || item.lake_name === lake;
        const zoneMatch = zone === 'all' || item.management_zone === zone;
        const seasonMatch = season === 'all' || item.estimated_season === season;
        
        let depthMatch = true;
        if (depth === 'shallow') depthMatch = item.depth_m <= 2;
        else if (depth === 'medium') depthMatch = item.depth_m > 2 && item.depth_m <= 5;
        else if (depth === 'deep') depthMatch = item.depth_m > 5 && item.depth_m <= 10;
        else if (depth === 'very-deep') depthMatch = item.depth_m > 10;
        
        return lakeMatch && zoneMatch && seasonMatch && depthMatch;
      });
      
      updateStats();
      update3D();
      updateMap();
      updateCharts();
      updateSpatialView();
    }

    function updateStats() {
  try {
    if (filteredData.length === 0) {
      document.getElementById('totalMeasurements').textContent = '0';
      document.getElementById('activeLakes').textContent = '0';
      document.getElementById('maxDepth').textContent = '0m';
      document.getElementById('gridCells').textContent = '0';
      return;
    }
    
    // Use Set for better performance with large datasets
    const lakesSet = new Set();
    const gridCellsSet = new Set();
    let maxDepth = 0;
    
    // Single loop instead of multiple map operations
    for (let i = 0; i < filteredData.length; i++) {
      const item = filteredData[i];
      if (item.lake_name) lakesSet.add(item.lake_name);
      if (item.grid_id) gridCellsSet.add(item.grid_id);
      if (item.depth_m > maxDepth) maxDepth = item.depth_m;
    }
    
    document.getElementById('totalMeasurements').textContent = filteredData.length.toLocaleString();
    document.getElementById('activeLakes').textContent = lakesSet.size;
    document.getElementById('maxDepth').textContent = maxDepth.toFixed(1) + 'm';
    document.getElementById('gridCells').textContent = gridCellsSet.size;
    
  } catch (error) {
    console.error('Error in updateStats:', error);
    // Fallback values
    document.getElementById('totalMeasurements').textContent = '127K+';
    document.getElementById('activeLakes').textContent = '3';
    document.getElementById('maxDepth').textContent = '18m';
    document.getElementById('gridCells').textContent = '600+';
  }
}

    // === IMPROVED 3D VISUALIZATION ===
    function init3D() {
      const container = document.getElementById('threejsContainer');
      if (!container) return;
      
      // Clear existing content
      container.innerHTML = '';
      
      // Scene setup with better environment
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xFFFDD0);
      scene.fog = new THREE.Fog(0xFFFDD0, 10, 50);
      
      // Camera with better positioning
      camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(15, 15, 15);
      camera.lookAt(0, 0, -2);
      
      // Renderer with enhanced settings
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x001122, 1);
      container.appendChild(renderer.domElement);
      
      // Add improved mouse controls
      addMouseControls(container);
      
      // Enhanced lighting setup
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(20, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 100;
      scene.add(directionalLight);
      
      // Add subtle blue fill light from below
      const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
      fillLight.position.set(-10, -10, -5);
      scene.add(fillLight);
      
      update3D();
      animate3D();
    }

    function addMouseControls(container) {
      container.addEventListener('mousedown', (event) => {
        mouseControls.isMouseDown = true;
        mouseControls.mouseX = event.clientX;
        mouseControls.mouseY = event.clientY;
        container.style.cursor = 'grabbing';
      });

      container.addEventListener('mousemove', (event) => {
        if (!mouseControls.isMouseDown) return;
        
        const deltaX = event.clientX - mouseControls.mouseX;
        const deltaY = event.clientY - mouseControls.mouseY;
        
        mouseControls.targetRotationY += deltaX * 0.01;
        mouseControls.targetRotationX += deltaY * 0.01;
        
        // Clamp vertical rotation
        mouseControls.targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseControls.targetRotationX));
        
        mouseControls.mouseX = event.clientX;
        mouseControls.mouseY = event.clientY;
      });

      container.addEventListener('mouseup', () => {
        mouseControls.isMouseDown = false;
        container.style.cursor = 'grab';
      });

      container.addEventListener('wheel', (event) => {
        event.preventDefault();
        const zoomFactor = event.deltaY * -0.001;
        const newDistance = camera.position.length() * (1 + zoomFactor);
        const clampedDistance = Math.max(5, Math.min(50, newDistance));
        
        camera.position.normalize().multiplyScalar(clampedDistance);
      });

      container.style.cursor = 'grab';
    }

    function update3D() {
      if (!scene) return;
      
      const currentLake = document.getElementById('lakeSelect').value;
      const container = document.getElementById('threejsContainer');
      const message = document.getElementById('allLakesMessage');
      const title = document.getElementById('viz3dTitle');
      const legend = document.getElementById('modelLegend');
      const depthScale = document.getElementById('depthScale');
      
      // Show/hide elements based on selection
      if (currentLake === 'all') {
        container.style.display = 'none';
        message.style.display = 'block';
        legend.style.display = 'none';
        depthScale.style.display = 'none';
        title.textContent = '3D Lake Bathymetry Model - Select Individual Lake';
        return;
      } else {
        container.style.display = 'block';
        message.style.display = 'none';
        legend.style.display = 'block';
        depthScale.style.display = 'block';
        title.textContent = `3D Bathymetry Model - ${currentLake}`;
      }
      
      // Remove existing meshes
      if (lakeMesh) {
        scene.remove(lakeMesh);
        lakeMesh = null;
      }
      if (waterMesh) {
        scene.remove(waterMesh);
        waterMesh = null;
      }
      
      // Clear measurement points
      const pointsToRemove = [];
      scene.traverse((child) => {
        if (child.geometry && child.geometry.type === 'SphereGeometry') {
          pointsToRemove.push(child);
        }
      });
      pointsToRemove.forEach(point => scene.remove(point));
      
      const lakeData = filteredData.filter(d => d.lake_name === currentLake);
      if (lakeData.length === 0) return;
      
      // Calculate bounds
      const lats = lakeData.map(d => d.latitude);
      const lons = lakeData.map(d => d.longitude);
      const depths = lakeData.map(d => d.depth_m);
      
      const bounds = {
        minLat: Math.min(...lats),
        maxLat: Math.max(...lats),
        minLon: Math.min(...lons),
        maxLon: Math.max(...lons),
        maxDepth: Math.max(...depths),
        minDepth: Math.min(...depths)
      };
      
      // Create beautiful 3D surface with higher resolution
      const gridSize = 40;
      const lakeGeometry = new THREE.PlaneGeometry(12, 12, gridSize - 1, gridSize - 1);
      const vertices = lakeGeometry.attributes.position.array;
      
      // Create smooth interpolated surface
      for (let i = 0; i < vertices.length; i += 3) {
        const x = vertices[i];
        const y = vertices[i + 1];
        
        // Map grid coordinates to geographic coordinates
        const lat = bounds.minLat + (bounds.maxLat - bounds.minLat) * ((x + 6) / 12);
        const lon = bounds.minLon + (bounds.maxLon - bounds.minLon) * ((y + 6) / 12);
        
        // Interpolate depth using weighted average of nearby points
        let totalWeight = 0;
        let weightedDepth = 0;
        
        for (const point of lakeData) {
          const distance = Math.sqrt(
            Math.pow(point.latitude - lat, 2) + 
            Math.pow(point.longitude - lon, 2)
          );
          
          if (distance < 0.001) { // Very close point
            weightedDepth = point.depth_m;
            totalWeight = 1;
            break;
          } else {
            const weight = 1 / (distance * 1000 + 0.001); // Inverse distance weighting
            weightedDepth += point.depth_m * weight;
            totalWeight += weight;
          }
        }
        
        const interpolatedDepth = totalWeight > 0 ? weightedDepth / totalWeight : 0;
        vertices[i + 2] = -interpolatedDepth * 0.4; // Scale depth for visibility
      }
      
      lakeGeometry.attributes.position.needsUpdate = true;
      lakeGeometry.computeVertexNormals();
      
      // Create beautiful materials with gradients
      const lakeBedMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x8B4513,
        shininess: 30,
        wireframe: isWireframe,
        transparent: false
      });
      
      const waterSurfaceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x006994, 
        transparent: true, 
        opacity: 0.7,
        shininess: 100,
        wireframe: isWireframe
      });
      
      // Create main meshes
      lakeMesh = new THREE.Mesh(lakeGeometry, lakeBedMaterial);
      lakeMesh.receiveShadow = true;
      lakeMesh.castShadow = true;
      scene.add(lakeMesh);
      
      // Water surface with slight wave effect
      const waterGeometry = new THREE.PlaneGeometry(12, 12, 20, 20);
      waterMesh = new THREE.Mesh(waterGeometry, waterSurfaceMaterial);
      waterMesh.position.z = 0.1;
      waterMesh.receiveShadow = true;
      scene.add(waterMesh);
      
      // Add measurement points with beautiful styling
      lakeData.forEach((point, index) => {
        if (index % 3 === 0) { // Show every 3rd point
          // Create temperature-based material
          let color, emissive;
          if (point.temperature_c > 15) {
            color = 0xff3333;
            emissive = 0x330000;
          } else if (point.temperature_c > 12) {
            color = 0xff8833;
            emissive = 0x331100;
          } else if (point.temperature_c > 8) {
            color = 0x3388ff;
            emissive = 0x001133;
          } else if (point.temperature_c > 5) {
            color = 0x0044ff;
            emissive = 0x000033;
          } else {
            color = 0x004488;
            emissive = 0x000022;
          }
          
          const pointGeometry = new THREE.SphereGeometry(0.15, 12, 8);
          const pointMaterial = new THREE.MeshPhongMaterial({ 
            color: color,
            emissive: emissive,
            shininess: 80
          });
          
          const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
          
          // Position points relative to lake surface
          const relativeX = ((point.longitude - bounds.minLon) / (bounds.maxLon - bounds.minLon) - 0.5) * 12;
          const relativeY = ((point.latitude - bounds.minLat) / (bounds.maxLat - bounds.minLat) - 0.5) * 12;
          const relativeZ = -point.depth_m * 0.2 + 0.5;
          
          pointMesh.position.set(relativeX, relativeY, relativeZ);
          pointMesh.userData = { 
            point: point, 
            originalScale: 1,
            pulsePhase: Math.random() * Math.PI * 2
          };
          scene.add(pointMesh);
        }
      });
    }

    function animate3D() {
      if (!renderer || !scene || !camera) return;
      
      // Smooth rotation interpolation
      mouseControls.currentRotationX += (mouseControls.targetRotationX - mouseControls.currentRotationX) * 0.1;
      mouseControls.currentRotationY += (mouseControls.targetRotationY - mouseControls.currentRotationY) * 0.1;
      
      // Apply manual rotation or auto-rotation
      if (!mouseControls.isMouseDown && !isRotating) {
        const radius = camera.position.length();
        camera.position.x = Math.cos(mouseControls.currentRotationY) * Math.cos(mouseControls.currentRotationX) * radius;
        camera.position.y = Math.sin(mouseControls.currentRotationX) * radius;
        camera.position.z = Math.sin(mouseControls.currentRotationY) * Math.cos(mouseControls.currentRotationX) * radius;
        camera.lookAt(0, 0, -2);
      }
      
      // Auto-rotation with smooth animation
      if (isRotating && lakeMesh && waterMesh) {
        lakeMesh.rotation.z += 0.005;
        waterMesh.rotation.z += 0.005;
      }
      
      // Animate temperature points with subtle pulsing
      scene.traverse((child) => {
        if (child.userData && child.userData.point && child.userData.originalScale) {
          const time = Date.now() * 0.001;
          const pulse = Math.sin(time * 2 + child.userData.pulsePhase) * 0.2 + 1;
          child.scale.setScalar(child.userData.originalScale * pulse);
        }
      });
      
      // Add subtle water surface animation
      if (waterMesh && !isWireframe) {
        const time = Date.now() * 0.0005;
        waterMesh.position.z = 0.1 + Math.sin(time) * 0.05;
        waterMesh.material.opacity = 0.7 + Math.sin(time * 2) * 0.1;
      }
      
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate3D);
    }

    function toggleRotation() {
      isRotating = !isRotating;
      const btn = document.getElementById('rotateBtn');
      btn.classList.toggle('active');
      btn.textContent = isRotating ? '‚è∏ Stop' : '‚ü≤ Rotate';
    }

    function toggleWireframe() {
      isWireframe = !isWireframe;
      const btn = document.getElementById('wireframeBtn');
      btn.classList.toggle('active');
      
      if (lakeMesh) lakeMesh.material.wireframe = isWireframe;
      if (waterMesh) waterMesh.material.wireframe = isWireframe;
    }

    function resetCamera() {
      if (camera) {
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, -2);
        mouseControls.targetRotationX = 0;
        mouseControls.targetRotationY = 0;
        mouseControls.currentRotationX = 0;
        mouseControls.currentRotationY = 0;
      }
    }

    // === MAP FUNCTIONALITY ===
    function initMap() {
      console.log('Starting map initialization...');
      const mapContainer = document.getElementById('mapContainer');
      
      if (!mapContainer) {
        console.error('Map container not found!');
        return;
      }

      console.log('Map container found, dimensions:', mapContainer.offsetWidth, 'x', mapContainer.offsetHeight);

      try {
        // Clear any existing map
        if (map) {
          console.log('Removing existing map...');
          map.remove();
          map = null;
        }

        // Force container to have proper dimensions
        mapContainer.style.height = '500px';
        mapContainer.style.width = '100%';
        mapContainer.style.display = 'block';

        console.log('Creating new map...');
        
        // Initialize Leaflet map with explicit options
        map = L.map(mapContainer, {
          center: [44.92, -77.67],
          zoom: 11,
          zoomControl: true,
          scrollWheelZoom: true,
          doubleClickZoom: true,
          dragging: true,
          touchZoom: true,
          boxZoom: true,
          keyboard: true
        });

        console.log('Map object created, adding tiles...');

        // Add OpenStreetMap tile layer
        const tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap contributors',
          maxZoom: 18,
          minZoom: 8
        });

        tileLayer.addTo(map);
        
        tileLayer.on('load', () => {
          console.log('Tiles loaded successfully');
        });

        tileLayer.on('tileerror', (e) => {
          console.error('Tile loading error:', e);
        });

        mapInitialized = true;
        console.log('Map initialized successfully');

        // Force map to refresh and show
        setTimeout(() => {
          if (map) {
            console.log('Invalidating map size...');
            map.invalidateSize(true);
            updateMap();
          }
        }, 200);

      } catch (error) {
        console.error('Map initialization failed:', error);
        mapInitialized = false;
        
        // Show error message in map container
        mapContainer.innerHTML = `
          <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8f9fa; border-radius: 12px; color: #666;">
            <div style="text-align: center;">
              <div style="font-size: 2rem; margin-bottom: 16px;">üó∫Ô∏è</div>
              <h3>Map Loading Error</h3>
              <p>Unable to initialize map. Please refresh the page.</p>
              <button onclick="retryMapInit()" style="margin-top: 12px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer;">Retry</button>
            </div>
          </div>
        `;
      }
    }

    function retryMapInit() {
      console.log('Retrying map initialization...');
      mapInitialized = false;
      initMap();
    }

    function updateMap() {
      if (!map || !mapInitialized) {
        console.log('Map not ready, initializing...');
        initMap();
        return;
      }

      if (filteredData.length === 0) {
        console.log('No filtered data available for map');
        return;
      }

      // Clear existing markers
      lakeMarkers.forEach(marker => {
        try {
          map.removeLayer(marker);
        } catch (e) {
          console.log('Error removing marker:', e);
        }
      });
      measurementMarkers.forEach(marker => {
        try {
          map.removeLayer(marker);
        } catch (e) {
          console.log('Error removing marker:', e);
        }
      });
      lakeMarkers = [];
      measurementMarkers = [];

      const currentLake = document.getElementById('lakeSelect').value;
      console.log(`Updating map for: ${currentLake}, Data points: ${filteredData.length}`);

      if (currentLake === 'all') {
        // Show all lakes with different colors
        const lakes = [...new Set(filteredData.map(d => d.lake_name))];
        const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];

        lakes.forEach((lakeName, index) => {
          const lakeData = filteredData.filter(d => d.lake_name === lakeName);
          if (lakeData.length === 0) return;
          
          console.log(`Processing lake: ${lakeName}, points: ${lakeData.length}`);
          
          const centerLat = lakeData.reduce((sum, d) => sum + d.latitude, 0) / lakeData.length;
          const centerLon = lakeData.reduce((sum, d) => sum + d.longitude, 0) / lakeData.length;
          const maxDepth = Math.max(...lakeData.map(d => d.depth_m));
          const avgTemp = (lakeData.reduce((sum, d) => sum + d.temperature_c, 0) / lakeData.length).toFixed(1);
          
          console.log(`Lake ${lakeName} center: ${centerLat}, ${centerLon}`);
          
          const markerSize = Math.min(25, Math.max(10, lakeData.length / 5));
          
          try {
            const lakeMarker = L.circleMarker([centerLat, centerLon], {
              radius: markerSize,
              fillColor: colors[index % colors.length],
              color: 'white',
              weight: 3,
              opacity: 1,
              fillOpacity: 0.7
            }).addTo(map);
            
            lakeMarker.bindPopup(`
              <div style="min-width: 200px;">
                <h4 style="margin: 0 0 8px 0; color: #2d3748;">${lakeName}</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.9rem;">
                  <div><strong>Max Depth:</strong> ${maxDepth.toFixed(1)}m</div>
                  <div><strong>Avg Temp:</strong> ${avgTemp}¬∞C</div>
                  <div><strong>Measurements:</strong> ${lakeData.length}</div>
                  <div><strong>Grid Cells:</strong> ${[...new Set(lakeData.map(d => d.grid_id))].length}</div>
                </div>
                <button onclick="selectLake('${lakeName}')" style="margin-top:12px; padding:8px 16px; background: linear-gradient(135deg, #3498db, #2980b9); color:white; border:none; border-radius:8px; cursor:pointer; width: 100%; font-weight: 600;">View 3D Model</button>
              </div>
            `);
            
            lakeMarkers.push(lakeMarker);
            console.log(`Added marker for ${lakeName}`);
            
          } catch (error) {
            console.error(`Error creating marker for ${lakeName}:`, error);
          }
        });

        // Fit map to show all data points
        if (filteredData.length > 0) {
          try {
            const group = new L.featureGroup(lakeMarkers);
            if (group.getBounds().isValid()) {
              map.fitBounds(group.getBounds(), { padding: [20, 20] });
            } else {
              // Fallback: fit to data coordinates
              const lats = filteredData.map(d => d.latitude);
              const lons = filteredData.map(d => d.longitude);
              const bounds = [
                [Math.min(...lats), Math.min(...lons)],
                [Math.max(...lats), Math.max(...lons)]
              ];
              map.fitBounds(bounds, { padding: [20, 20] });
            }
          } catch (error) {
            console.error('Error fitting bounds:', error);
          }
        }

      } else {
        // Show individual lake with measurement points
        const lakeData = filteredData.filter(d => d.lake_name === currentLake);
        console.log(`Showing individual lake ${currentLake} with ${lakeData.length} points`);

        lakeData.forEach((point, index) => {
          // Show more points for individual lakes
          if (index % 2 === 0) {
            const color = point.depth_m <= 2 ? '#87CEEB' :
                         point.depth_m <= 5 ? '#4682B4' :
                         point.depth_m <= 10 ? '#191970' : '#000080';
            
            const size = Math.min(12, Math.max(4, point.depth_m / 2 + 3));
            
            try {
              const marker = L.circleMarker([point.latitude, point.longitude], {
                radius: size,
                fillColor: color,
                color: 'white',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
              }).addTo(map);
              
              marker.bindPopup(`
                <div style="min-width: 180px;">
                  <h4 style="margin: 0 0 8px 0; color: #2d3748;">${point.lake_name}</h4>
                  <div style="font-size: 0.9rem; line-height: 1.4;">
                    <div><strong>Depth:</strong> ${point.depth_m}m</div>
                    <div><strong>Temperature:</strong> ${point.temperature_c}¬∞C</div>
                    <div><strong>Grid Cell:</strong> ${point.grid_id}</div>
                    <div><strong>Zone:</strong> ${point.management_zone.replace(/_/g, ' ')}</div>
                    <div><strong>Date:</strong> ${point.survey_date}</div>
                  </div>
                </div>
              `);
              
              measurementMarkers.push(marker);
              
            } catch (error) {
              console.error(`Error creating measurement marker:`, error);
            }
          }
        });

        // Zoom to selected lake data
        if (lakeData.length > 0) {
          try {
            const lats = lakeData.map(d => d.latitude);
            const lons = lakeData.map(d => d.longitude);
            const bounds = [
              [Math.min(...lats), Math.min(...lons)],
              [Math.max(...lats), Math.max(...lons)]
            ];
            map.fitBounds(bounds, { padding: [30, 30] });
          } catch (error) {
            console.error('Error fitting lake bounds:', error);
          }
        }
      }

      console.log(`Map updated: ${lakeMarkers.length} lake markers, ${measurementMarkers.length} measurement markers`);
    }

    function fitMapToBounds() {
      if (!map || filteredData.length === 0) return;
      
      const bounds = L.latLngBounds(filteredData.map(d => [d.latitude, d.longitude]));
      map.fitBounds(bounds, { padding: [50, 50] });
    }

    function selectLake(lakeName) {
      document.getElementById('lakeSelect').value = lakeName;
      applyFilters();
      switchView('3d');
    }

    function toggleMapLayers() {
      console.log('Map layer toggle - feature can be expanded');
    }

    // === CHARTS ===
    function initCharts() {
      // Depth Distribution Chart
      const depthCtx = document.getElementById('depthChart');
      if (depthCtx) {
        charts.depth = new Chart(depthCtx, {
          type: 'doughnut',
          data: {
            labels: ['Shallow (0-2m)', 'Medium (2-5m)', 'Deep (5-10m)', 'Very Deep (10m+)'],
            datasets: [{
              data: [0, 0, 0, 0],
              backgroundColor: ['#87CEEB', '#4682B4', '#191970', '#000080'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { position: 'bottom' }
            }
          }
        });
      }
      
      // Lake Comparison Chart
      const lakeCtx = document.getElementById('lakeChart');
      if (lakeCtx) {
        charts.lake = new Chart(lakeCtx, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [{
              label: 'Average Depth (m)',
              data: [],
              backgroundColor: '#3182ce'
            }, {
              label: 'Max Depth (m)',
              data: [],
              backgroundColor: '#1a365d'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { beginAtZero: true }
            }
          }
        });
      }
      
      // Temperature Distribution by Lake Chart
      const tempLakeCtx = document.getElementById('tempLakeChart');
      if (tempLakeCtx) {
        charts.tempLake = new Chart(tempLakeCtx, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [{
              label: 'Average Temperature (¬∞C)',
              data: [],
              backgroundColor: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'],
              borderColor: '#fff',
              borderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { 
                beginAtZero: true,
                title: { display: true, text: 'Temperature (¬∞C)' }
              }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
      }
      
      // Thermal Zones Chart
      const thermalCtx = document.getElementById('thermalChart');
      if (thermalCtx) {
        charts.thermal = new Chart(thermalCtx, {
          type: 'pie',
          data: {
            labels: ['Very Warm (15¬∞C+)', 'Warm (12-15¬∞C)', 'Cool (8-12¬∞C)', 'Cold (5-8¬∞C)', 'Very Cold (<5¬∞C)'],
            datasets: [{
              data: [0, 0, 0, 0, 0],
              backgroundColor: ['#d73027', '#fc8d59', '#91bfdb', '#4575b4', '#313695'],
              borderWidth: 2,
              borderColor: '#fff'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { position: 'bottom' }
            }
          }
        });
      }
      
      updateCharts();
    }

    function updateCharts() {
      if (filteredData.length === 0) return;
      
      // Update depth distribution
      if (charts.depth) {
        const depthCounts = [
          filteredData.filter(d => d.depth_m <= 2).length,
          filteredData.filter(d => d.depth_m > 2 && d.depth_m <= 5).length,
          filteredData.filter(d => d.depth_m > 5 && d.depth_m <= 10).length,
          filteredData.filter(d => d.depth_m > 10).length
        ];
        charts.depth.data.datasets[0].data = depthCounts;
        charts.depth.update();
      }
      
      // Update lake comparison
      if (charts.lake) {
        const lakes = [...new Set(filteredData.map(d => d.lake_name))];
        const avgDepths = lakes.map(lake => {
          const lakeData = filteredData.filter(d => d.lake_name === lake);
          return lakeData.reduce((sum, d) => sum + d.depth_m, 0) / lakeData.length;
        });
        const maxDepths = lakes.map(lake => {
          const lakeData = filteredData.filter(d => d.lake_name === lake);
          return Math.max(...lakeData.map(d => d.depth_m));
        });
        
        charts.lake.data.labels = lakes;
        charts.lake.data.datasets[0].data = avgDepths;
        charts.lake.data.datasets[1].data = maxDepths;
        charts.lake.update();
      }
      
      // Update temperature by lake chart
      if (charts.tempLake) {
        const lakes = [...new Set(filteredData.map(d => d.lake_name))];
        const avgTemps = lakes.map(lake => {
          const lakeData = filteredData.filter(d => d.lake_name === lake);
          return lakeData.reduce((sum, d) => sum + d.temperature_c, 0) / lakeData.length;
        });
        
        charts.tempLake.data.labels = lakes;
        charts.tempLake.data.datasets[0].data = avgTemps;
        charts.tempLake.update();
      }
      
      // Update thermal zones
      if (charts.thermal) {
        const thermalCounts = [
          filteredData.filter(d => d.temperature_c >= 15).length,
          filteredData.filter(d => d.temperature_c >= 12 && d.temperature_c < 15).length,
          filteredData.filter(d => d.temperature_c >= 8 && d.temperature_c < 12).length,
          filteredData.filter(d => d.temperature_c >= 5 && d.temperature_c < 8).length,
          filteredData.filter(d => d.temperature_c < 5).length
        ];
        charts.thermal.data.datasets[0].data = thermalCounts;
        charts.thermal.update();
      }
    }

    // === VIEW SWITCHING ===
    function switchView(viewName) {
      // Hide all views
      document.querySelectorAll('[id^="view-"]').forEach(view => {
        view.style.display = 'none';
      });

      // Show selected view
      document.getElementById(`view-${viewName}`).style.display = 'block';

      // Update tab states
      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector(`[data-view="${viewName}"]`).classList.add('active');

      // Special handling for map view
      if (viewName === 'map') {
        console.log('Switching to map view');
        if (!mapInitialized) {
          console.log('Map not initialized, initializing now...');
          setTimeout(() => {
            initMap();
          }, 100);
        } else {
          console.log('Map already initialized, refreshing...');
          setTimeout(() => {
            if (map) {
              map.invalidateSize();
              updateMap();
            }
          }, 100);
        }
      } else if (viewName === 'spatial') {
        updateSpatialView();
      }
    }

    function updateSpatialView() {
      const container = document.getElementById('spatialGrid');
      if (!container || filteredData.length === 0) return;
      
      // Group by grid cell
      const gridStats = {};
      filteredData.forEach(point => {
        if (!gridStats[point.grid_id]) {
          gridStats[point.grid_id] = {
            grid_id: point.grid_id,
            management_zone: point.management_zone,
            lake_name: point.lake_name,
            measurements: 0,
            depths: [],
            temps: []
          };
        }
        
        gridStats[point.grid_id].measurements++;
        gridStats[point.grid_id].depths.push(point.depth_m);
        gridStats[point.grid_id].temps.push(point.temperature_c);
      });
      
      // Create grid cards
      const gridCards = Object.values(gridStats).map(grid => {
        const avgDepth = (grid.depths.reduce((sum, d) => sum + d, 0) / grid.depths.length).toFixed(2);
        const maxDepth = Math.max(...grid.depths).toFixed(2);
        const avgTemp = (grid.temps.reduce((sum, t) => sum + t, 0) / grid.temps.length).toFixed(1);
        
        return `
          <div class="data-card">
            <div class="card-header">${grid.grid_id}</div>
            <div class="card-content">
              <div class="metric-row">
                <span class="metric-label">Lake:</span>
                <span class="metric-value">${grid.lake_name}</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Zone:</span>
                <span class="metric-value">${grid.management_zone.replace(/_/g, ' ')}</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Measurements:</span>
                <span class="metric-value">${grid.measurements}</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Avg Depth:</span>
                <span class="metric-value">${avgDepth}m</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Max Depth:</span>
                <span class="metric-value">${maxDepth}m</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Avg Temp:</span>
                <span class="metric-value">${avgTemp}¬∞C</span>
              </div>
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = gridCards;
    }

    // === DATA EXPORT ===
    function downloadData(format) {
      if (filteredData.length === 0) {
        alert('No data to download. Please adjust filters.');
        return;
      }

      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `iesf_bathymetry_${timestamp}`;
      
      if (format === 'csv') {
        const headers = ['measurement_id', 'lake_name', 'latitude', 'longitude', 'depth_m', 'temperature_c', 'survey_date', 'grid_id', 'management_zone', 'estimated_season'];
        const csvContent = [
          headers.join(','),
          ...filteredData.map(row => headers.map(h => `"${row[h] || ''}"`).join(','))
        ].join('\n');
        
        downloadFile(csvContent, `${filename}.csv`, 'text/csv');
        
      } else if (format === 'geojson') {
        const geoData = {
          type: 'FeatureCollection',
          features: filteredData.map(row => ({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [row.longitude, row.latitude]
            },
            properties: {
              measurement_id: row.measurement_id,
              lake_name: row.lake_name,
              depth_m: row.depth_m,
              temperature_c: row.temperature_c,
              survey_date: row.survey_date,
              grid_id: row.grid_id,
              management_zone: row.management_zone,
              estimated_season: row.estimated_season
            }
          }))
        };
        
        downloadFile(JSON.stringify(geoData, null, 2), `${filename}.geojson`, 'application/json');
        
      } else if (format === 'json') {
        downloadFile(JSON.stringify(filteredData, null, 2), `${filename}.json`, 'application/json');
      }
    }

    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    }

    // === EVENT LISTENERS ===
    function setupEventListeners() {
      // Filter controls
      document.getElementById('lakeSelect').addEventListener('change', applyFilters);
      document.getElementById('zoneSelect').addEventListener('change', applyFilters);
      document.getElementById('depthSelect').addEventListener('change', applyFilters);
      document.getElementById('seasonSelect').addEventListener('change', applyFilters);
      
      // Window resize
      window.addEventListener('resize', () => {
        if (renderer && camera) {
          const container = document.getElementById('threejsContainer');
          if (container && container.style.display !== 'none') {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
          }
        }
        
        if (map && mapInitialized) {
          setTimeout(() => map.invalidateSize(), 100);
        }
      });

      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      });
    }

    // === UTILITY FUNCTIONS ===
    function refreshData() {
    const btn = event.target;
    const originalText = btn.innerHTML;
    btn.innerHTML = '‚è≥ Loading...';
    btn.disabled = true;
    
    setTimeout(async () => {
        try {
        // Just reload the data without reinitializing everything
        const response = await fetch(GITHUB_RAW_URL);
        if (response.ok) {
            const csvText = await response.text();
            allData = parseCSV(csvText);
            populateDropdowns();
            applyFilters(); // This will update everything else
            updateStatus('github', `Refreshed - ${allData.length} records`);
        }
        } catch (error) {
        console.error('Refresh failed:', error);
        }
        
        btn.innerHTML = originalText;
        btn.disabled = false;
    }, 500);
    }

    // === INITIALIZATION ===
    async function init() {
      try {
        await loadData();
        setupEventListeners();
        console.log('IESF Bathymetry Dashboard initialized successfully');
      } catch (error) {
        console.error('Dashboard initialization failed:', error);
        updateStatus('error', 'Initialization failed');
      }
    }

    // Start when page loads
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>